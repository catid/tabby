/*
	Copyright (c) 2013 Christopher A. Taylor.  All rights reserved.

	Redistribution and use in source and binary forms, with or without
	modification, are permitted provided that the following conditions are met:

	* Redistributions of source code must retain the above copyright notice,
	  this list of conditions and the following disclaimer.
	* Redistributions in binary form must reproduce the above copyright notice,
	  this list of conditions and the following disclaimer in the documentation
	  and/or other materials provided with the distribution.
	* Neither the name of Tabby nor the names of its contributors may be
	  used to endorse or promote products derived from this software without
	  specific prior written permission.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
	LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
	CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
	SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
	INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
	CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
	ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
	POSSIBILITY OF SUCH DAMAGE.
*/

#include "tabby.h"
#include "snowshoe.h"
#include "cymric.h"
#include "blake2.h"

#include "Platform.hpp"
#include "SecureErase.hpp"
using namespace cat;

static bool m_initialized = false;

typedef struct {
	// Key/nonce generator
	cymric_rng rng;

	// Generated/loaded private key
	char private_key[32];

	// Corresponding public key
	char public_key[64];

	// Nonce generated for this connection
	char nonce[32];

	// Flag indicating initialization for error checking
	u32 flag;
} client_internal;

typedef struct {
	// Key/nonce generator
	cymric_rng rng;

	// Secret key used consistently during signing
	// It is important that this key is never changed,
	// or else the signatures can leak the private key.
	char sign_key[32];

	// Generated/loaded private key
	char private_key[32];

	// Corresponding public key, always regenerated from
	// the private key to avoid validation and to cut
	// down on the offline storage.
	char public_key[64];

	// Private ephemeral key, used for forward secrecy,
	// which should be periodically rekeyed.
	char private_ephemeral[32];

	// Its corresponding public ephemeral key
	char public_ephemeral[64];

	// Flag indicating initialization for error checking
	u32 flag;

	// Rekey thread data:

	// New ephemeral key generated by rekeying.
	// This key will get copied over to private_ephemeral
	// next time a client connects to the server.
	char private_rekey[32];

	// New corresponding public key generated by rekeying
	char public_rekey[64];

	// New RNG state after reseeding the generator.
	// This RNG state will get copied over the main RNG
	// next time a client connects to the server.
	cymric_rng rng_rekey;

	// Flag to indicate whether rekeying is requested or
	// completed.  When rekeying is not requested, it is
	// okay to do nothing and have the thread go back to
	// sleep.  The problem is that the ephemeral secret
	// is not erased from memory until the next time a
	// client connects, which is not ideal.
	volatile u32 flag_rekey;
} server_internal;

// Valid flag values
static const u32 FLAG_INIT = 0x11223344;

// Valid rekey flag values
static const u32 FLAG_NEED_REKEY = 1;	// Requesting a rekey
static const u32 FLAG_REKEY_DONE = 2;	// Done with rekey

// Check if x == 0 in constant-time
static bool is_zero(const char x[32]) {
	const u64 *k = (const u64 *)x;
	const u64 zero = k[0] | k[1] | k[2] | k[3];
	const u32 z = (u32)(zero | (zero >> 32));
	return z == 0;
}

// Check if x == y in constant-time
static bool is_equal(const char x[32], const char y[32]) {
	const u64 *k = (const u64 *)x;
	const u64 *l = (const u64 *)y;
	const u64 zero = (k[0] ^ l[0]) | (k[1] ^ l[1]) | (k[2] ^ l[2]) | (k[3] ^ l[3]);
	const u32 z = (u32)(zero | (zero >> 32));
	return z == 0;
}

static int generate_key(cymric_rng *rng, char private_key[32], char public_key[64]) {
	// Reuse public key buffer for 64 bytes of private key material
	char *key = public_key;

	// For each attempt,
	do {
		// If Cymric was not able to generate a random value,
		if (cymric_random(rng, key, 64)) {
			// Give up
			return -1;
		}

		// Reduce 512-bit key material modulo Snowshoe q to produce
		// a private key uniformly distributed in the range 0..q-1.
		// Uniformity is verified experimentally; see `docs/fold.cpp`.

		// This is not what is needed exactly, since 0 is an invalid
		// private key.  But it is passed to snowshoe_mul_gen(), which
		// will validate the key, and it will error out if the rare 0
		// case occurs.

		snowshoe_mod_q(key, private_key);

		// Some other implentations of ECC have a faster key generation
		// process where they will just mask some bits (e.g. Ed25519)
		// on a random input, which gives away a few bits of security
		// in return for faster and deterministic key generation.

		// Tabby's approach offers a higher security level, which makes
		// up for the "security level bits" lost by using an efficient
		// endomorphism to speed up curve math, and is not much slower
		// in practice (<2% overhead) than masking.  And key generation
		// is rarely a bottleneck in practice.

		// Using keys uniformly distributed in 1..q-1 is important
		// for Tabby because later on the private keys are combined as
		// `k = k1 * H + k2` similar to EdDSA.  If k1 or k2 are biased
		// due to masking bits, then the resulting value `k` has a
		// large bias according to some 18-bit simulations.  So to avoid
		// this problem, strong uniformly-distributed keys are used.
	} while (snowshoe_mul_gen(private_key, public_key, 0));

	return 0;
}

#ifdef __cplusplus
extern "C" {
#endif

int _tabby_init(int expected_version) {
	// If ABI compatibility is uncertain,
	if (expected_version != TABBY_VERSION) {
		return -1;
	}

	// If the internal version of the server structure is bigger
	// than the one that the user sees,
	if (sizeof(server_internal) > sizeof(tabby_server)) {
		return -1;
	}

	// If the internal version of the client structure is bigger
	// than the one that the user sees,
	if (sizeof(client_internal) > sizeof(tabby_client)) {
		return -1;
	}

	// If Cymric cannot initialize,
	if (cymric_init()) {
		return -1;
	}

	// If Snowshoe cannot initialize,
	if (snowshoe_init()) {
		return -1;
	}

	// Flag initialized true so we can do sanity checks later
	m_initialized = true;
	return 0;
}

int tabby_server_gen(tabby_server *S, const void *seed, int seed_bytes) {
	server_internal *state = (server_internal *)S;

	// Input validation
	if (!S) {
		return -1;
	}

	// Reseed the generator
	if (cymric_seed(&state->rng, seed, seed_bytes)) {
		return -1;
	}

	// Generate the long-term key pair
	if (generate_key(&state->rng, state->private_key, state->public_key)) {
		return -1;
	}

	// Generate the long-term signing key
	if (cymric_random(&state->rng, state->sign_key, 32)) {
		return -1;
	}

	// Generate the ephemeral key pair afterwards to avoid any chance of leaking
	// information about the long-term keys in ephemeral data
	if (generate_key(&state->rng, state->private_ephemeral, state->public_ephemeral)) {
		return -1;
	}

	// Flag as initialized for sanity checking later
	state->flag = FLAG_INIT;

	// Flag as needing a rekey
	state->flag_rekey = FLAG_NEED_REKEY;

	return 0;
}

int tabby_client_gen(tabby_client *C, const void *seed, int seed_bytes, char client_request[96]) {
	client_internal *state = (client_internal *)C;

	// Input validation
	if (!C || !client_request) {
		return -1;
	}

	// Reseed the generator
	if (cymric_seed(&state->rng, seed, seed_bytes)) {
		return -1;
	}

	// Generate the client's ephemeral key pair
	if (generate_key(&state->rng, state->private_key, state->public_key)) {
		return -1;
	}

	// Generate a random nonce after the private key to avoid any chance of leaking
	// information about the private key in public information
	if (cymric_random(&state->rng, state->nonce, 32)) {
		return -1;
	}

	// Construct the request object, which is:
	// (client public key[64]) (client nonce[32])
	memcpy(client_request, state->public_key, 64);
	memcpy(client_request + 64, state->nonce, 32);

	// Flag the object as initialized for sanity checking later
	state->flag = FLAG_INIT;

	return 0;
}

int tabby_client_rekey(const tabby_client *existing, tabby_client *C, const void *seed, int seed_bytes, char client_request[96]) {
	client_internal *old_state = (client_internal *)existing;
	client_internal *state = (client_internal *)C;

	// Input validation
	if (!existing || !C || !client_request || state->flag != FLAG_INIT) {
		return -1;
	}

	// Derive a new generator from the old one, which does not reseed.
	// This is this main point of using tabby_client_rekey() instead of
	// tabby_client_gen() because the rekeying does not consume more
	// /dev/random randomness and avoids blocking.
	if (cymric_derive(&state->rng, &old_state->rng, seed, seed_bytes)) {
		return -1;
	}

	// Use the same key pair as before.  There is no reason to change it
	// since the session secret varies with the client's nonce.
	memcpy(state->private_key, old_state->private_key, 32);
	memcpy(state->public_key, old_state->public_key, 64);

	// Generate a new random client nonce.
	// This is the main result of rekeying, and it makes it impossible
	// for a malicious server to replay a previously recorded session
	// with a legitimate server and arrive at the same session key.
	if (cymric_random(&state->rng, state->nonce, 32)) {
		return -1;
	}

	// Fill the client request object
	memcpy(client_request, state->public_key, 64);
	memcpy(client_request + 64, state->nonce, 32);

	// Set the initialized flag for sanity checking later
	state->flag = FLAG_INIT;

	return 0;
}

int tabby_get_public_key(tabby_server *S, char public_key[64]) {
	server_internal *state = (server_internal *)S;

	// Validate input and make sure the server object was initialized
	if (!S || !public_key || state->flag != FLAG_INIT) {
		return -1;
	}

	// Copy out the public key
	memcpy(public_key, state->public_key, 64);

	return 0;
}

int tabby_server_save(tabby_server *S, char server_data[64]) {
	server_internal *state = (server_internal *)S;

	// Validate input and make sure the server object was initialized
	if (!S || !server_data || state->flag != FLAG_INIT) {
		return -1;
	}

	// Copy out the private and sign keys, which need to
	// persist between server runs.  The public key can
	// be trivially derived during loading, which avoids
	// the potential for corruption at least for that.
	memcpy(server_data, state->private_key, 32);
	memcpy(server_data + 32, state->sign_key, 32);

	return 0;
}

int tabby_server_load(tabby_server *S, const void *seed, int seed_bytes, const char server_data[64]) {
	server_internal *state = (server_internal *)S;

	// Validate input
	if (!S || !server_data) {
		return -1;
	}

	// Copy the private and sign keys into the target location
	memcpy(state->private_key, server_data, 32);
	memcpy(state->sign_key, server_data + 32, 32);

	// Regenerate the public key from the private key
	if (snowshoe_mul_gen(state->private_key, state->public_key, 0)) {
		return -1;
	}

	// Reseed the Cymric RNG for generating nonces and ephemeral key pairs
	if (cymric_seed(&state->rng, seed, seed_bytes)) {
		return -1;
	}

	// Generate the server's ephemeral key pair
	if (generate_key(&state->rng, state->private_ephemeral, state->public_ephemeral)) {
		return -1;
	}

	// Flag the object as being initialized for sanity checking later
	state->flag = FLAG_INIT;

	// Flag that we want a rekey initially
	state->flag_rekey = FLAG_NEED_REKEY;

	return 0;
}

int tabby_sign(tabby_server *S, const void *message, int bytes, char signature[96]) {
	server_internal *state = (server_internal *)S;

	// If library is not initialized,
	if (!m_initialized) {
		return -1;
	}

	// If input is invalid or server object is not initialized,
	if (!state || !message || bytes <= 0 || !signature || state->flag != FLAG_INIT) {
		return -1;
	}

	// Hash the signature key with the message to produce a random value,
	// rather than generating a random value, which is a trick recommended
	// by the Ed25519 paper.

	// r = BLAKE2(sign_key, M) mod q
	char r[64];
	if (blake2b((u8*)r, message, state->sign_key, 64, bytes, 32)) {
		return -1;
	}
	snowshoe_mod_q(r, r);

	// This produces a random value in 0...q-1, which is very unlikely
	// to be zero.  As implemented, the signature will fail in this case.
	// This means that a very small number of messages cannot be signed,
	// but it is incredibly unlikely to ever happen.

	// R = rG
	char *R = signature;
	if (snowshoe_mul_gen(r, R, 1)) {
		return -1;
	}

	// Hash the public key, R, and the message together and reduce the
	// 512-bit result modulo q.  This is H(R,A,M) from Ed25519.

	// t = BLAKE2(SP, R, M) mod q
	char t[64];
	blake2b_state B;
	blake2b_init(&B, 64);
	blake2b_update(&B, (const u8 *)state->public_key, 64);
	blake2b_update(&B, (const u8 *)R, 64);
	blake2b_update(&B, (const u8 *)message, bytes);
	blake2b_final(&B, (u8 *)t, 64);
	snowshoe_mod_q(t, t);

	// Combine the two uniformly distributed keys with the private key:

	// s = r + t*SS (mod q)
	char *s = signature + 64;
	snowshoe_mul_mod_q(t, state->private_key, r, s);

	CAT_SECURE_OBJCLR(r);
	CAT_SECURE_OBJCLR(t);

	return 0;
}

int tabby_verify(const void *message, int bytes, const char public_key[64], char signature[96]) {
	// If library is not initialized,
	if (!m_initialized) {
		return -1;
	}

	// If input is invalid,
	if (!public_key || !message || bytes <= 0 || !signature) {
		return -1;
	}

	// Reconstruct the same hash as on the server.  This is H(R,A,M) from Ed25519.

	// t = BLAKE2(SP, R, M) mod q
	char *R = signature;
	char t[64];
	blake2b_state B;
	blake2b_init(&B, 64);
	blake2b_update(&B, (const u8 *)public_key, 64);
	blake2b_update(&B, (const u8 *)R, 64);
	blake2b_update(&B, (const u8 *)message, bytes);
	blake2b_final(&B, (u8 *)t, 64);
	snowshoe_mod_q(t, t);

	// Negate the public key and perform a simultaneous multiplication as in Ed25519
	// to check the signature.

	// u = sG - tSP
	char u[64];
	char *s = signature + 64;
	snowshoe_neg(public_key, u);
	if (snowshoe_simul_gen(s, t, u, u)) {
		return -1;
	}

	// Check if the points match.  This does not need to be done in constant-time.

	const u64 *X = (const u64 *)u;
	const u64 *Y = (const u64 *)R;
	for (int ii = 0; ii < 8; ++ii) {
		if (X[ii] != Y[ii]) {
			return -1;
		}
	}

	// No need to clear sensitive data from memory here: It is all public knowledge

	return 0;
}

int tabby_server_rekey(tabby_server *S, const void *seed, int seed_bytes) {
	server_internal *state = (server_internal *)S;

	if (!m_initialized) {
		return -1;
	}

	if (state->flag != FLAG_INIT) {
		return -1;
	}

	// If a new key is requested,
	if (state->flag_rekey == FLAG_NEED_REKEY) {
		CAT_FENCE_COMPILER;

		// Copy RNG state
		memcpy(&state->rng_rekey, &state->rng, sizeof(state->rng_rekey));

		// Seed new RNG
		if (cymric_seed(&state->rng_rekey, seed, seed_bytes)) {
			return -1;
		}

		// Generate ephemeral key pair
		if (generate_key(&state->rng_rekey, state->private_rekey, state->public_rekey)) {
			return -1;
		}

		CAT_FENCE_COMPILER;

		// Flag rekey complete
		state->flag_rekey = FLAG_REKEY_DONE;
	}

	return 0;
}

int tabby_server_handshake(tabby_server *S, const char client_request[96], char server_response[128], char secret_key[32]) {
	server_internal *state = (server_internal *)S;

	if (!m_initialized) {
		return -1;
	}

	if (state->flag != FLAG_INIT) {
		return -1;
	}

	if (!state || !client_request || !server_response || !secret_key) {
		return -1;
	}

	// If rekeying is complete,
	if (state->flag_rekey == FLAG_REKEY_DONE) {
		CAT_FENCE_COMPILER;

		// Copy over the generated ephemeral key pair
		memcpy(state->private_ephemeral, state->private_rekey, 32);
		memcpy(state->public_ephemeral, state->public_rekey, 64);

		// Copy over the new RNG state
		memcpy(&state->rng, &state->rng_rekey, sizeof(state->rng));

		CAT_FENCE_COMPILER;

		// Allow thread to rekey again
		state->flag_rekey = FLAG_NEED_REKEY;
	}

	char T[64+64+32];
	char *H = T + 64;
	char *h = T + 64+64;
	char *e = h;
	char *k = T;
	char *nonce = server_response + 64;
	const char *client_public = client_request;
	const char *client_nonce = client_request + 64;

	do {
		do {
			// Generate server nonce SN
			if (cymric_random(&state->rng, nonce, 32)) {
				return -1;
			}

			// H = BLAKE2(CP, CN, EP, SP, SN)
			blake2b_state B;
			blake2b_init(&B, 64);
			blake2b_update(&B, (const u8 *)client_public, 64);
			blake2b_update(&B, (const u8 *)client_nonce, 32);
			blake2b_update(&B, (const u8 *)state->public_ephemeral, 64);
			blake2b_update(&B, (const u8 *)state->public_key, 64);
			blake2b_update(&B, (const u8 *)nonce, 32);
			blake2b_final(&B, (u8 *)H, 64);

			// h = H mod q
			snowshoe_mod_q(H, h);

			// If h == 0, choose a new SN and start over.
		} while (is_zero(h));

		// e = h * SS + ES (mod q)
		snowshoe_mul_mod_q(h, state->private_key, state->private_ephemeral, e);

		// If e == 0, choose a new SN and start over.
	} while (is_zero(e));

	// T = e * SP
	if (snowshoe_mul(e, client_public, T)) {
		return -1;
	}

	// k = BLAKE2(T, H)
	if (blake2b((u8 *)k, T, 0, 64, 128, 0)) {
		return -1;
	}

	// Secret key = low 32 bytes of k
	memcpy(secret_key, k, 32);

	// Write server ephemeral public key
	memcpy(server_response, state->public_ephemeral, 64);

	// PROOF = high 32 bytes of k
	memcpy(server_response + 32 + 64, k + 32, 32);

	CAT_SECURE_OBJCLR(T);

	return 0;
}

int tabby_client_handshake(tabby_client *C, const char server_public_key[64], const char server_response[128], char secret_key[32]) {
	client_internal *state = (client_internal *)C;

	if (!m_initialized) {
		return -1;
	}

	if (state->flag != FLAG_INIT) {
		return -1;
	}

	if (!state || !server_public_key || !server_response || !secret_key) {
		return -1;
	}

	char T[64+64+32];
	char *H = T + 64;
	char *h = T + 64+64;
	char *d = h;
	char *k = T;
	const char *EP = server_response;
	const char *SN = server_response + 64;
	const char *PROOF = server_response + 96;

	// H = BLAKE2(CP, CN, EP, SP, SN)
	blake2b_state B;
	blake2b_init(&B, 64);
	blake2b_update(&B, (const u8 *)state->public_key, 64);
	blake2b_update(&B, (const u8 *)state->nonce, 32);
	blake2b_update(&B, (const u8 *)EP, 64);
	blake2b_update(&B, (const u8 *)server_public_key, 64);
	blake2b_update(&B, (const u8 *)SN, 32);
	blake2b_final(&B, (u8 *)H, 64);

	// h = H mod q
	snowshoe_mod_q(H, h);

	// Validate h != 0.
	if (is_zero(h)) {
		return -1;
	}

	// d = h * CS (mod q)
	snowshoe_mul_mod_q(h, state->private_key, 0, d);

	// Validate that d != 0
	if (is_zero(d)) {
		return -1;
	}

	// T = CS * EP + d * SP
	if (snowshoe_simul(state->private_key, EP, d, server_public_key, T)) {
		return -1;
	}

	// k = BLAKE2(T, H)
	if (blake2b((u8 *)k, T, 0, 64, 128, 0)) {
		return -1;
	}

	// Verify the high 32 bytes of k matches PROOF
	if (!is_equal(PROOF, k + 32)) {
		return -1;
	}

	// Session key is the low 32 bytes of k
	memcpy(secret_key, k, 32);

	CAT_SECURE_OBJCLR(T);

	return 0;
}

void tabby_erase(void *object, int bytes) {
	if (object && bytes > 0) {
		cat_secure_erase(object, bytes);
	}
}

#ifdef __cplusplus
}
#endif

