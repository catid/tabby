## Tabby Password Authentication

Tabby implements a new augmented zero-knowledge proof password authentication
protocol based on the elliptic curve SPAKE2 protocol [1] modified for further
efficiency by using Elligator [2].  It is designed to be a replacement for SRP6a
that runs ~30x faster on the server.  Best practices for password strengthening
are employed in this design.

The password authentication is designed to be run after the handshake completes.
It is best to encrypt the authentication process rather than sending it in the
clear, although like SRP it can be sent in the clear.  The difference is that
the password authentication only does that: Authenticates passwords.  It does
not *also* come up with a shared secret key, because the Tabby handshake has
already done this.

One perhaps unexpected benefit of this password authentication process is that
the *server* demonstrates knowledge of the password also, which allows the
client to detect a MitM attack when the server's public key is not trusted.

Another unusual advantage of this password authentication process is that the
information stored on the server to verify the user's login cannot be used to
log into the server without brute-forcing the password.  This makes Tabby an
"augmented" password protocol.

And finally and most importantly, if the other party does not know the password,
then they are given only one guess at the password per online exchange.  And
there is no feasible way to crack the password offline based on what is learned
during the communication otherwise.  This property stems from the zero-knowledge
proofs at the heart of the protocol.

Tabby password authentication also follows best password protection practices
by incorporating salts, realms, strengthening, and a memory-intensive KDF to
make passwords as difficult to crack as possible.


#### Function Definitions

Some of the functions run during the protocol should be specified:

PBKDF(pw, salt) is [Lyra](http://eprint.iacr.org/2014/030.pdf) with parameters:

+ saltSize = 16 bytes
+ timeCost = 10 (# of iterations)
+ blocksPerRow = 64 (# of 64 byte hash blocks per matrix row)
+ nRows = 1000 (# of 4KB rows => 4MB)
+ Output = 64 bytes

This runs in about 120 milliseconds on a laptop.  BCRYPT or some other PBKDF
may be a better choice here, based on what happens in the [PHC](https://password-hashing.net/).

H(m) is BLAKE2-bp.

CSPRNG is [Cymric](https://github.com/catid/cymric).

v,V, salt = tabby_password(username, realm, password):

~~~
	salt = CSPRNG(16 bytes)
	pw = H("username : realm : password")
	v = PBKDF(salt, pw) [512 bits, 64 bytes]
	v = v (mod q) [using Snowshoe, q = prime subgroup order]
	Repeat from the top if v = 0.
	V = vG [using Snowshoe, 72 bytes]
~~~


#### Protocol Specification

Client generates password:

To create an account, the client sends "username, salt, V" to the server for storage.  V is generated by `tabby_password()`.

Now a client wants to connect to the server.

Client transmits:

~~~
c2s username
~~~

Server Online Processing:

~~~
	Lookup database entry for username, recovering "V, salt".

	E = snowshoe_elligator(H(V, salt)):
		Elligator deterministically maps a 32 byte number to a curve point.
		The point is multiplied by 4 (see discussion).

	Choose random x = [1, q-1]

	X' = snowshoe_elligator_encrypt(x, E):
		X = xG
		X' = X + E
~~~

Server transmits:

~~~
s2c salt[16 bytes], X'[64 bytes]
~~~

Client Online Processing:

~~~
	v,V = tabby_password(username, realm, password, salt)

	E = snowshoe_elligator(H(V, salt))

	Choose random y = [1, q-1]

	Y' = snowshoe_elligator_encrypt(y, E):
		Y = yG
		Y' = Y + E

	Z = snowshoe_elligator_secret(v+y, X', E):
		X = X' - E
		Z = (v + y)X

	SPROOF, CPROOF = H(E, server_public_key, Z):
		CPROOF is low 32 bytes, SPROOF is high 32 bytes.
~~~

Client transmits:

~~~
c2s Y'[64 bytes], CPROOF[32 bytes]
~~~

Server Online Processing:

~~~
	Z = snowshoe_elligator_secret(x, Y', V, E):
		Y = Y' - E
		Z = x(Y + V)

	SPROOF, CPROOF = H(E, server_public_key, Z):

	Verify CPROOF.  Disconnect on proof mismatch.
~~~

Server transmits:

~~~
s2c SPROOF[32 bytes]
~~~

Client Online Processing:

~~~
	Verify SPROOF.  Disconnect on proof mismatch.
~~~

It is important that the client and server do not accept any messages
except for password login messages until the proofs are received.


#### Protocol Discussion

There is a flaw in this protocol that leads to an offline dictionary attack from the server's first response of X'.  X is always of order q, but Elligator generates points E of order 4q.  And the sum is sent in the clear.  So for example, if X' = X + E is of order q, then you can eliminate all passwords that do not lead to a point of order q.  The approach I took to fix this is to multiply the Elligator output by 4, which guarantees that the result is a point of order q.  However, more time needs to be spent validating this approach.

Another area to pay attention to is how it is incorporated into the Tabby protocol.  I envision it being nested within a PKI-protected authenticated encryption scheme to allow for deniability, so that the client's username is not sent in the clear.  The issue that can happen is that if the server's public key is self-signed, then MitM is possible, and the attacker can relay the password protocol through to the real server to trick the user into thinking the attacker knows the password.  To prevent this, the server's public key makes an appearance in the final Z hash.  If the client is expecting the MitM public key, then the server will not verify correctly.

Sadly, deniability is lost when the server's public key is self-signed because a MitM would be able to watch the exchange up until the final server proof message, which would tell the MitM that the user knows his own password.  So if the server's public key is not known ahead of time, an active attacker can determine if the client owns the account, despite that the client will discover the subterfuge.

Some modifications to the protocol can be discussed:

If the salt is removed from the protocol, then the client is able to send data earlier, which would remove one message from the protocol, and the server would send a proof before the client.  There are pros and cons to having the server prove knowledge first.  In both cases, both sides get to guess just one password.  However, all sources of information on password security indicate a salt twice as large as the birthday attack is essential, so it should not be removed.

A larger salt can be chosen easily.  I'm considering increasing it to 16 bytes, though in my own estimation, a database of 4 billion users seems like a good upper limit already.

Another modification could be to send a hash of the PROOF and keep the PROOF value as a shared secret key.  This would allow the protocol to be used as a drop-in replacement for SRP.  Since this is the only implementation, it may be a good idea.  Other re-organization ideas like splitting Cymric from Tabby are being considered to make it more flexible.


#### Security Proof

This is a work in progress.  Stay tuned.


### References

##### [1] ["Thesis: Reducing The Need For Trusted Parties In Cryptography" (Abdalla 2011)](http://www.di.ens.fr/~mabdalla/papers/hdrthesis.pdf)
Provides thorough analysis of PAKE protocol SPAKE2, a basis for the Tabby protocol

##### [2] ["Elligator: Elliptic-curve points indistinguishable from uniform random strings" (Bernstein Hamburg Krasnova Lange 2013)](http://elligator.cr.yp.to/elligator-20130828.pdf)
Introduces the Elligator-2 point unpacking algorithm, which is implemented by Snowshoe

