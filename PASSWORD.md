## Tabby Password Authentication

Tabby implements a new augmented zero-knowledge proof password authentication
protocol based on the elliptic curve SPAKE2 protocol [1] modified for further
efficiency by using Elligator [2].  It is designed to be a replacement for SRP6a
that runs ~30x faster on the server.  Best practices for password strengthening
are employed in this design.

The password authentication is designed to be run after the handshake completes.
It is best to encrypt the authentication process rather than sending it in the
clear, although like SRP it can be sent in the clear.  The difference is that
the password authentication only does that: Authenticates passwords.  It does
not *also* come up with a shared secret key, because the Tabby handshake has
already done this.

One perhaps unexpected benefit of this password authentication process is that
the *server* demonstrates knowledge of the password also, which allows the
client to detect a MitM attack when the server's public key is not trusted.

Another unusual advantage of this password authentication process is that the
information stored on the server to verify the user's login cannot be used to
log into the server without brute-forcing the password.  This makes Tabby an
"augmented" password protocol.

Tabby password authentication also follows best password protection practices
by incorporating salts, realms, strengthening, and a memory-intensive KDF to
make passwords as difficult to crack as possible.


#### Function Definitions

Some of the functions run during the protocol should be specified:

PBKDF(pw, salt) is Lyra with parameters:

+ saltSize = 8 bytes
+ timeCost = 1000 (# of iterations)
+ blocksPerRow = 64 (# of 64 byte hash blocks per matrix row)
+ nRows = 8 (# of 4KB rows => 32KB)
+ Output = 64 bytes

H(m) is BLAKE2-bp.

CSPRNG is [Cymric](https://github.com/catid/cymric).

v,V = tabby_password(username, realm, password):

~~~
	salt = CSPRNG(8 bytes)
	pw = H("username : realm : password")
	v = PBKDF(salt, pw) [512 bits, 64 bytes]
	v = v (mod q) [using Snowshoe, q = prime subgroup order]
	Repeat from the top if v = 0.
	V = salt || vG [using Snowshoe, 72 bytes]
~~~


#### Protocol Specification

Client generates password:

To create an account, the client sends "username, salt, V" to the server for storage.  V is generated by `tabby_password()`.

Now a client wants to connect to the server.

Client transmits:

~~~
c2s username
~~~

Server Online Processing:

~~~
	Lookup database entry for username, recovering "salt, V".

	E = snowshoe_elligator(H(V, salt)):
		Elligator deterministically maps a 32 byte number to a curve point.

	Choose random x = [1, q-1]

	X' = snowshoe_elligator_encrypt(x, E):
		X = xG
		X' = X + E
~~~

Server transmits:

~~~
s2c salt, X'
~~~

Client Online Processing:

~~~
Regenerate V from password, salt:

	v,V = tabby_password(username, realm, password)

	E = snowshoe_elligator(H(V, salt))

	Choose random y = [1, q-1]

	Y' = snowshoe_elligator_encrypt(y, E):
		Y = yG
		Y' = Y + E

	Z = snowshoe_elligator_secret(v+y, X', E):
		X = X' - E
		Z = (v + y)X

	SPROOF, CPROOF = H(E, server_public_key, Z):
		CPROOF is low 32 bytes, SPROOF is high 32 bytes.
~~~

Client transmits:

~~~
c2s Y', CPROOF
~~~

Server Online Processing:

~~~
	Z = snowshoe_elligator_secret(x, Y', V, E):
		Y = Y' - E
		Z = x(Y + V)

	SPROOF, CPROOF = H(E, server_public_key, Z):

	Verify CPROOF.  Disconnect on proof mismatch.
~~~

Server transmits:

~~~
s2c SPROOF
~~~

Client Online Processing:

~~~
	Verify SPROOF.  Disconnect on proof mismatch.
~~~

It is important that the client and server do not accept any messages
except for password login messages until the proofs are received.


### References

##### [1] ["Thesis: Reducing The Need For Trusted Parties In Cryptography" (Abdalla 2011)](http://www.di.ens.fr/~mabdalla/papers/hdrthesis.pdf)
Provides thorough analysis of PAKE protocol SPAKE2, a basis for the Tabby protocol

##### [2] ["Elligator: Elliptic-curve points indistinguishable from uniform random strings" (Bernstein Hamburg Krasnova Lange 2013)](http://elligator.cr.yp.to/elligator-20130828.pdf)
Introduces the Elligator-2 point unpacking algorithm, which is implemented by Snowshoe

